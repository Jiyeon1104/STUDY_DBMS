BEGIN
	DBMS_OUTPUT.PUT_LINE('HELLO');
END;

--F(X) = 2X + 1
--단, X는 정수이다.
CREATE OR REPLACE PROCEDURE F
(
	X NUMBER 
)
IS
BEGIN 
	DBMS_OUTPUT.PUT_LINE(2 * X + 1);
END;

CALL F(2);

DROP PROCEDURE F;
----------------------------------------------
DECLARE
	SCORE NUMBER := 88;
	GRADE VARCHAR2(5);
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F';
	END IF;
	DBMS_OUTPUT.PUT_LINE('당신의 점수 : ' ||SCORE||'점'||CHR(10)||'학점 : '||GRADE);
END;
--------------------------------------------------------------------
-- 위에 있는 학점 쿼리문을 프로시저로 제작하여 실행한다.
-- F학점이라면 '넌 소중해' 출력하기
CREATE OR REPLACE PROCEDURE GET_GRADE
(
	SCORE NUMBER
)
IS
	GRADE VARCHAR2(5)
BEGIN
	IF SCORE >= 90 THEN GRADE := 'A';
	ELSIF SCORE >= 80 THEN GRADE := 'B';
	ELSIF SCORE >= 70 THEN GRADE := 'C';
	ELSIF SCORE >= 60 THEN GRADE := 'D';
	ELSE GRADE := 'F'; DBMS_OUTPUT.PUT_LINE('넌 소중해');
	END IF;
	DBMS_OUTPUT.PUT_LINE('당신의 점수 : ' ||SCORE||'점'||CHR(10)||'학점 : '||GRADE);
END;

CALL GET_GRADE(5);
--------------------------------------------------------------
SELECT * FROM JOBS;

CREATE OR REPLACE PROCEDURE PROC_NEW_JOB
(
	P_JOB_ID IN JOBS.JOB_ID%TYPE,
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
BEGIN 
	INSERT INTO JOBS
	(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
	VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
	DBMS_OUTPUT.PUT_LINE('ALL DONE ABOUT '||P_JOB_ID);
END;

CALL PROC_NEW_JOB('IT', 'Developer', 14000, 50000);

SELECT * FROM JOBS;

--JOBS 테이블에서 JOB_ID로 삭제하는 프로시저 선언
--JOB_ID가 있을 때에만 삭제할 수 있도록 구현
CREATE OR REPLACE PROCEDURE PROC_DEL_JOB
(
	P_JOB_ID JOBS.JOB_ID%TYPE
)
IS
	CNT NUMBER := 0;
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT FROM JOBS
	WHERE JOB_ID = P_JOB_ID;
	IF CNT != 0
	THEN
		DELETE FROM JOBS
		WHERE JOB_ID = P_JOB_ID;
		DBMS_OUTPUT.PUT_LINE('DELETE ALL DONE ABOUT '||P_JOB_ID);
	ELSE
		DBMS_OUTPUT.PUT_LINE('NOT EXIST '||P_JOB_ID);
	END IF;
END;

CALL PROC_DEL_JOB('IT');

SELECT * FROM JOBS;

------------------------------------------------------------------------------
-- JOBS 테이블에 데이터를 전달받은 후 INSERT 하는 프로시저 제작
-- 만약 INSERT가 되지 않는다면 UPDATE를 하도록 구현
CREATE OR REPLACE PROCEDURE PROC_NEW_JOB_OR_UPDATE_JOB
(
	P_JOB_ID IN JOBS.JOB_ID%TYPE,
	P_JOB_TITLE IN JOBS.JOB_TITLE%TYPE,
	P_MIN_SALARY IN JOBS.MIN_SALARY%TYPE,
	P_MAX_SALARY IN JOBS.MAX_SALARY%TYPE
)
IS
	CNT NUMBER := 0;
BEGIN
	SELECT COUNT(JOB_ID) INTO CNT FROM JOBS WHERE JOB_ID = P_JOB_ID;
	IF CNT = 0
	THEN
		INSERT INTO JOBS
		(JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY)
		VALUES(P_JOB_ID, P_JOB_TITLE, P_MIN_SALARY, P_MAX_SALARY);
		DBMS_OUTPUT.PUT_LINE('INSERT ALL DONE ABOUT '||P_JOB_ID);
	ELSE
		UPDATE JOBS
		SET JOB_TITLE = P_JOB_TITLE, MIN_SALARY = P_MIN_SALARY, MAX_SALARY = P_MAX_SALARY
		WHERE JOB_ID = P_JOB_ID;
		DBMS_OUTPUT.PUT_LINE('UPDATE ALL DONE ABOUT '||P_JOB_ID);
	END IF;
END;

CALL PROC_NEW_JOB_OR_UPDATE_JOB('IT', 'Developer', 14000, 50000); 

SELECT * FROM JOBS;

SELECT TO_NUMBER("HOUR") "HOUR", COUNT(*) FROM
(SELECT TO_CHAR(HIREDATE, 'HH24') "HOUR" FROM EMP)
GROUP BY "HOUR";

SELECT ROWNUM, LEVEL - 1, 3 FROM EMP
CONNECT BY LEVEL <= 3;

SELECT COUNT(*) FROM
(
	SELECT LEVEL FROM DUAL
	CONNECT BY LEVEL <= 10
);

SELECT HIREDATE FROM EMP

SELECT HIREDATE FROM EMP WHERE ROWNUM = 1;

SELECT LEVEL - 1, 
(SELECT HIREDATE FROM EMP WHERE ROWNUM = LEVEL) 
FROM DUAL
CONNECT BY LEVEL <= 14;

SELECT LEVEL
FROM EMP
CONNECT BY LEVEL <= 10;

SELECT COUNT(ENAME) FROM EMP;
SELECT 14 * 14 FROM DUAL;

SELECT LEV, C FROM
(
	SELECT LEVEL AS LEV FROM DUAL
	CONNECT BY LEVEL <= 12
)
LEFT OUTER JOIN
(
	SELECT TO_CHAR(HIREDATE, 'MM') M, COUNT(*) C FROM EMP
	GROUP BY TO_CHAR(HIREDATE, 'MM')
) 
ON LEV = M
ORDER BY 1;


SELECT HIREDATE AS LEV FROM EMP
WHERE ROWNUM <= 25;


SELECT R, TO_CHAR(HIREDATE, 'MM'), COUNT(*) FROM EMP, (SELECT ROWNUM R FROM DUAL CONNECT BY ROWNUM <= 12)
GROUP BY GROUPING SETS
(
	(R, TO_CHAR(HIREDATE, 'MM'))
)
ORDER BY 1;

SELECT * FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') IN (SELECT ROWNUM R FROM DUAL CONNECT BY ROWNUM <= 12);

SELECT
	CASE ROWNUM WHEN TO_NUMBER(TO_CHAR(HIREDATE, 'MM')) THEN 1 ELSE 2 END
FROM EMP
CONNECT BY ROWNUM <= 12
GROUP BY ROWNUM, HIREDATE;


SELECT ROWNUM R, COUNT(HIREDATE)
FROM EMP 
CONNECT BY ROWNUM <= 12
GROUP BY ROWNUM;

SELECT * FROM EMP;























